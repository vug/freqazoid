<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Audio API</title>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script src="../dist/vendor/dsp.js"></script>
</head>
<body>
<div id="app">
    <div class="param-num">
        <label>x</label>
        <input type="range" min="20" max="2000" v-model.number="x">
        <input type="range" min="20" max="2000" v-model.number="x">
        {{x}}
    </div>

    <div class="param-num">
        <label>gain</label>
        <input type="range" min="0" max="1.0" step="0.01" v-model.number="ae.gain.gain.value">
        <input type="range" min="0" max="1.0" step="0.01" v-model.number="ae.gain.gain.value">
        {{ae.gain.gain.value}}
    </div>

    <div class="param-num">
        <label>frequency</label>
        <input type="range" min="20" max="2000" v-model.number="ae.oscillator.frequency.value">
        <input type="range" min="20" max="2000" v-model.number="ae.oscillator.frequency.value">
        {{ae.oscillator.frequency.value}}
    </div>

    <div class="param-num">
        <label>analyser smoothing time constant</label>
        <input type="range" min="0.0" max="1.0" step="0.01" v-model.number="ae.analyser.smoothingTimeConstant">
        <input type="range" min="0.0" max="1.0" step="0.01" v-model.number="ae.analyser.smoothingTimeConstant">
        {{ae.analyser.smoothingTimeConstant}}
    </div>

    <div class="param-sel">
        <label>type</label>
        <select v-model="ae.oscillator.type">
            <option>sine</option>
            <option>square</option>
            <option>sawtooth</option>
            <option>triangle</option>
            <option>custom</option>
        </select>
    </div>

    <div>
        <label>audioContext</label>
        <button v-on:click="pauseAudioEngine">{{enginePlaying ? 'pause' : 'play'}}</button>
    </div>
</div>

<div id="osc" style="width: 100%; height: 300px"></div>
<div id="spc" style="width: 100%; height: 300px"></div>

<script>
/**
 * Cut an array into numSlices arrays with mostly equal length
 * @param {Array} arr An array of numbers
 * @param numSlices Number of slice arrays
 * @returns {Array}
 */
function slicesOfArray(arr, numSlices) {
	var q = arr.length / numSlices;
	var t = 0;
	var slices = [];

	for(var i=0; i<numSlices; i++) {
		var ixp = Math.floor(t);
		var ix = Math.floor(t + q);
		var slice = arr.slice(ixp, ix);
		slices.push(slice);
		t += q;
	}
	return slices;
}

/**
 * The sum of all items in an array
 * @param {Array} arr
 * @returns {Number} Sum
 */
function sum(arr) {
    return arr.reduce((prev, curr) => prev + curr);
}

/**
 * The item in an array that has the largest absolute value
 * @param {Array} arr
 * @returns {Number}
 */
function absoluteMax(arr) {
    var ix = -1;
    var absMax = -Infinity;
    for (var k = 0; k < arr.length; k++) {
        var abs = Math.abs(arr[k]);
        if (abs > absMax) {
            ix = k;
            absMax = abs;
        }
    }
    return arr[ix];
}

class AnalysisBuffer {
    constructor(context, hopSize, numHops) {
        this.context = context;
        this.hopSize = hopSize;
        this.numHops = numHops;

        this.frame = new Float32Array(this.hopSize * this.numHops);
        this.fft = new FFT(this.frame.length, 44100);
        this.peaks = [];

        this.node = this.context.createScriptProcessor(this.hopSize, 1, 1);
        this.node.onaudioprocess = (audioProcessingEvent) => {
            var time = audioProcessingEvent.playbackTime;
            var inputBuffer = audioProcessingEvent.inputBuffer;
            var outputBuffer = audioProcessingEvent.outputBuffer;
            var inputData = inputBuffer.getChannelData(0);
            var outputData = outputBuffer.getChannelData(0);

            outputData.set(inputData);

            this.frame.copyWithin(0, this.hopSize);
            this.frame.set(inputData, this.hopSize * (this.numHops - 1));

            this.fft.forward(this.frame);

            this.peaks = [];
            var mag = this.fft.spectrum;
            for(var ix = 1; ix < mag.length - 1; ix++) {
                if(mag[ix] > mag[ix - 1] && mag[ix] > mag[ix + 1] && mag[ix] > 0.05) {
                    this.peaks.push(ix);
                }
            }
        };
    }
}

window.AudioContext = window.AudioContext || window.webkitAudioContext;
class AudioEngine {
    constructor() {
        this.context = new window.AudioContext();

        this.oscillator = this.context.createOscillator();
        this.gain = this.context.createGain();
        this.analyser = this.context.createAnalyser();
//        this.analysisBuffer = new AnalysisBuffer(this.context, 1024, 4);
        this.analysisBuffer = new AnalysisBuffer(this.context, 2048, 2);

        this.oscillator.type = 'sine';
        this.oscillator.frequency.value = 440;
        this.oscillator.start();
        this.gain.gain.value = 0.5;
        this.analyser.smoothingTimeConstant = 0.5;

        this.analyser.fftSize = 2048;

        this.oscillator.connect(this.analysisBuffer.node);
        this.analysisBuffer.node.connect(this.gain);
        this.analysisBuffer.node.connect(this.analyser);
        this.gain.connect(this.context.destination);
    }
}

class AudioVisualization {
    constructor(analyser, elemId) {
        this.analyser = analyser;
        this.elemId = elemId;

        this.div = document.getElementById(this.elemId);
        this.div.style.setProperty('outline', 'solid 1px');
        this.div.style.setProperty('display', 'inline-block');
        this.canvas = document.createElement('canvas');
        this.resize();
        this.div.appendChild(this.canvas);
        this.context = this.canvas.getContext('2d');

        this.buffer = new Float32Array(this.analyser.frequencyBinCount);

        this.animate();
    }

    render() {

    }

    resize() {
        this.canvas.width = this.div.clientWidth;
        this.canvas.height = this.div.clientHeight;
    }

    animate() {
        this.render();

        requestAnimationFrame(this.animate.bind(this));
    }
}

class Oscilloscope extends AudioVisualization {
    render() {
        this.buffer = this.analyser.frame;
        var ctx = this.context;
        var width = this.canvas.width;
        var height = this.canvas.height;
        var halfHeight = height * 0.5;

        var slices = slicesOfArray(this.buffer, width);
        var sliceMaxes = slices.map((slice) => absoluteMax(slice));


        ctx.clearRect(0, 0, width, height);
        ctx.beginPath();
        if(false) {
            // A line for every sample
            ctx.moveTo(0, this.buffer[0]);
            for (var x=1; x<this.buffer.length; x++) {
                var sample = this.buffer[x];
                var y = sample * halfHeight + halfHeight;
                ctx.lineTo(x / this.buffer.length * width, y);
            }
        }
        else {
            // Absolute Max
            ctx.moveTo(0, sliceMaxes[0]);
            for (var x=1; x<width; x++) {
                var sample = sliceMaxes[x];
                var y = sample * halfHeight + halfHeight;
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
    }
}

class Spectroscope extends AudioVisualization {
    render() {
        this.buffer = this.analyser.fft.spectrum;
        var ctx = this.context;
        var width = this.canvas.width;
        var height = this.canvas.height;

        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        for (var ix=0; ix<this.buffer.length; ix++) {
            var y = height -  this.buffer[ix] * height;
            var x = ix / this.buffer.length * width;
            ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.strokeStyle = 'green';
        for (var ix=0; ix<this.analyser.peaks.length; ix++) {
            var peak = this.analyser.peaks[ix];
            ctx.beginPath();
            var x = peak / this.buffer.length * width;
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }


    }
}

var ae = new AudioEngine();
var osc = new Oscilloscope(ae.analysisBuffer, 'osc');
var spc = new Spectroscope(ae.analysisBuffer, 'spc');
var visualizations = [osc, spc];
for (let vis of visualizations) {
    window.addEventListener('resize', vis.resize.bind(vis), false);
}
var vue =  new Vue({
    el: '#app',
    data: {
        ae: ae,
        enginePlaying: true,
        x: 100
    },
    methods: {
        pauseAudioEngine: function() {
            if(this.ae.context.state === "running") {
                this.ae.context.suspend();
                this.enginePlaying = false;
            }
            else if(this.ae.context.state === "suspended") {
                this.ae.context.resume();
                this.enginePlaying = true;
            }
        }
    },
    computed: {

    }
});
    
</script>
</body>
</html>